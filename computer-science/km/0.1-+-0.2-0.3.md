# 0.1 + 0.2 !== 0.3



### 為什麼0.1 + 0.2 !== 0.3？如何解決這個問題？

在二進制科學表示法中，<mark style="color:blue;">雙精度浮點的小數部分</mark>最多只能保留52 位（比如 `1.xxx... * 2^n`，小數點後的 `x` 最多保留52 位），加上前面的1，其實就是保留53 位有效數字，**超過這個長度的位數會被捨去（會採用 `0舍1入` 的方式），這樣就造成了精度丟失的問題**。

由於小數的運算可能導致精度丟失問題，那麼要解決這個問題，可以將其轉換為整數後再進行運算，運算後再轉換為對應的小數



* 來自 為什麼0.1 + 0.2 !== 0.3？如何解決這個問題？[https://blog.csdn.net/mubo970901/article/details/108052108](https://blog.csdn.net/mubo970901/article/details/108052108)
* `JavaScript` 中數字的存儲遵循 `IEEE 754` 標準，是以64 位雙精度格式來存儲數字的，JS ES6 `ES6` 中的極小數 `Number.EPSILON` 來進行判斷
